#!/usr/bin/perl -w
#
# rename - rename old style foo.digits.gz files
#
# usage:
#	find dir -type f -name '*.gz' | ./rename
#
# @(#) $Revision: 1.30 $
# @(#) $Id: savelog,v 1.30 2000/02/05 21:39:58 chongo Exp chongo $
# @(#) $Source: /usr/local/src/etc/savelog/RCS/savelog,v $
#
# Copyright (c) 2000 by Landon Curt Noll.  All Rights Reserved.
#
# Permission to use, copy, modify, and distribute this software and
# its documentation for any purpose and without fee is hereby granted,
# provided that the above copyright, this permission notice and text
# this comment, and the disclaimer below appear in all of the following:
#
#       supporting documentation
#       source copies
#       source works derived from this source
#       binaries derived from this source or from derived source
#
# LANDON CURT NOLL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
# INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO
# EVENT SHALL LANDON CURT NOLL BE LIABLE FOR ANY SPECIAL, INDIRECT OR
# CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
# USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
# OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
# PERFORMANCE OF THIS SOFTWARE.
#
# chongo <was here> /\oo/\
#
# Share and enjoy!

# requirements
#
use strict;
use English;

# my vars
#
my $exit_val;		# how we will exit
my $gzip;		# location of the gzip program

# main
#
MAIN:
{
    # my vars
    #
    my $file;		# the current file we are processing
    my @list;		# list of files read
    my $now;		# the time now
    #
    my $cur;		# current non-timestamp name
    my $cur_tstamp;	# current file timestamp
    #
    my $prev;		# previous non-timestamp name
    my $prev_tstamp;	# previous file timestamp
    #
    my $i;

    # setup
    #
    $exit_val = 0;	# hope for the best
    select STDOUT;
    $| = 1;
    if (-x "/bin/gzip") {
	$gzip = "/bin/gzip";
    } elsif (-x "/usr/bin/gzip") {
	$gzip = "/usr/bin/gzip";
    } elsif (-x "/usr/local/bin/gzip") {
	$gzip = "/usr/local/bin/gzip";
    } elsif (-x "/usr/gnu/bin/gzip") {
	$gzip = "/usr/gnu/bin/gzip";
    } elsif (-x "/usr/freeware/bin/gzip") {
	$gzip = "/usr/freeware/bin/gzip";
    } else {
	$gzip = "gzip";
    }
    $now = time();

    # read files from stdin
    #
    while (defined($file = <>)) {
	chomp $file;
	push(@list, $file);
    }

    # sort in quasi-numeric order
    #
    @list = sort tstamp_cmp @list;

    # rename going thru the list
    #
    $prev = "";
    $prev_tstamp = $now;
    for $file (@list) {

	# deterine the non-timestamp part of the name
	#
	($cur = $file) =~ s/\d+\.gz$//;

	# if we have a new fileset, then assume a prev timestamp of now
	#
	if ($cur ne $prev) {
	    $prev_tstamp = $now;
	}

	# determine the modification time of the file
	#
	(undef, undef, undef, undef, undef, undef, undef, undef, undef,
	 $cur_tstamp) = stat($file);
	if (! defined($cur_tstamp)) {
	    &err_msg(12, "cannot stat $file");
	}
	if ($prev_tstamp < $cur_tstamp) {
	    &warn_msg(0, "backtrack for $file, changing time from $cur_tstamp to $prev_tstamp-1");
	    $cur_tstamp = $prev_tstamp-1;
	}

	# rename file
	#
#	print "mv $file $cur$cur_tstamp-$prev_tstamp.gz\n";
	if (! rename($file, "$cur$cur_tstamp-$prev_tstamp.gz")) {
	    &warn_msg(14, "can't mv $file $cur$cur_tstamp-$prev_tstamp.gz");
	}

	# perform mail indexing
	#
#	print "/usr/local/lib/savelog/mail $cur$cur_tstamp-$prev_tstamp.gz\n";
	system("/usr/local/lib/savelog/mail $cur$cur_tstamp-$prev_tstamp.gz");

	# get ready for the next file
	#
	$prev = $cur;
	$prev_tstamp = $cur_tstamp;
    }

    # all done
    #
    print "\nDEBUG: exit code: $exit_val\n";
    exit $exit_val;
}

# err_msg - report an error and exit
#
# usage:
#	&err_msg(exitcode, "error format" [,arg ...])
#
sub err_msg($$@)
{
    # parse args
    #
    my ($code, $fmt, @args) = @_;
    $fmt = "<<no error message given>>" unless defined $fmt;
    $code = 2 unless defined $code;

    # issue message
    #
    print STDERR "$0: ERROR($code): ";
    if (defined @args) {
    	printf STDERR $fmt, @args;
    } else {
    	print STDERR $fmt;
    }
    print STDERR "\n";

    # exit
    #
    print "DEBUG: exit code was: $exit_val\n";
    $exit_val = $code;
    print "DEBUG: exit code: $exit_val\n";
    exit $exit_val;
}


# warn_msg - report an problem and continue
#
# usage:
#	&warn_msg(exitcode, "warning format" [,arg ...])
#
# NOTE: Unlike
#
sub warn_msg($$@)
{
    # parse args
    #
    my ($code, $fmt, @args) = @_;
    $fmt = "<<no warning message given>>" unless defined $fmt;
    $code = 3 unless defined $code;

    # issue message
    #
    print STDERR "$0: Warn($code): ";
    if (defined @args) {
    	printf STDERR $fmt, @args;
    } else {
    	print STDERR $fmt;
    }
    print STDERR "\n";

    # set the exit code but do not exit
    #
    print "DEBUG: exit code was: $exit_val\n";
    $exit_val = $code;
    print "DEBUG: exit code is now: $exit_val\n";
}


# untaint - untaint a filename
#
# usage:
#	&untaint($file)
#
# returns:
#	untainted $file or calls &err_msg()
#
# This function helps ensure that the filenames used to not have bad or
# dangerous chars in them.  It is designed to pass -T taint-perl inspection.
#
sub untaint($)
{
    my $file = $_[0];		# get arg

    if ($file =~ m#^([-\@\w./+:%,][-\@\w./+:%,~]*)$#) {
    	$file = $1;
    } else {
	&err_msg(16, "file has dangerous chars: $file");
    }
    return $file;
}


# tstamp_cmp - sort function to sort files by timestamp
#
# usage:
#	@array = sort tstamp_cmp @array;
#
# returns:
#	-1 ==> $a < $b
#	 0 ==> $a == $b
#	 1 ==> $a > $b
#
# Files are sorted in timestamp order.  The 1st timestamp (or the only
# timestamp of the file only has one) is the primary order.  The 2nd
# timestamp, if it exists, is the secondary order.
#
# A file with one timestamp is sorted before a file with two timestamps
# where the 1st stamp is the same.
#
# A files timestamp(s) are sorted after a files without any timestamps.
# Files without timestamps are sorted in cmp (string) order.  Files with
# equivalent timestamps are sorted in cmp (string) order.
#
sub tstamp_cmp()
{
    my $a_f = "";	# non-timestamp basename
    my $a_t1 = -1;	# first timestamp for $a or -1
    my $b_f = "";	# non-timestamp basename
    my $b_t1 = -1;	# first timestamp for $b or -1

    # determine the timestamps of $a
    #
    if ($a =~ m#^(.*)\.(\d+)\.gz$#) {
	$a_f = $1;
	$a_t1 = $2;
    } else {
	&warn_msg(123, "bad filename: $a");
    }

    # determine the timestamps of $b
    #
    if ($b =~ m#^(.*)\.(\d+)\.gz$#) {
	$b_f = $1;
	$b_t1 = $2;
    } else {
	&warn_msg(124, "bad filename: $b");
    }

    # compare non-timestamps
    #
    if ($a_f lt $b_f) {
	return -1;
    } elsif ($a_f gt $b_f) {
	return 1;
    }

    # compare timestamps
    #
    if ($a_t1 < $b_t1) {
	return -1;
    } elsif ($a_t1 > $b_t1) {
	return 1;
    }
    return $a cmp $b;
}
